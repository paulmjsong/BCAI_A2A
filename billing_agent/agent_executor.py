### WORK IN PROGRESS ###

import json
from web3 import Web3, HTTPProvider
from solcx import compile_source, install_solc

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import DataPart, Part, Task, TaskState, TextPart, UnsupportedOperationError
from a2a.utils import new_agent_parts_message, new_agent_text_message, new_task

from google.adk.agents.llm_agent import LlmAgent
from google.adk.artifacts import InMemoryArtifactService
from google.adk.memory.in_memory_memory_service import InMemoryMemoryService
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService


# Connect to WorldLand RPC
w3 = Web3(HTTPProvider('https://seoul.worldland.foundation'))
assert w3.is_connected(), "Failed to connect to Worldland RPC"
chain_id = 103

# Set up deployer account
deployer_private_key = "YOUR_PRIVATE_KEY_HERE"  # <- replace with actual private key
deployer_account = w3.eth.account.from_key(deployer_private_key)
deployer_address = deployer_account.address

# Compile smart contract
with open('./BillingContract.sol', 'r') as file:
    solidity_source = file.read()
install_solc('0.8.17')
compiled_sol = compile_source(solidity_source, output_values=['abi', 'bin'])
contract_id, contract_interface = compiled_sol.popitem()
abi = contract_interface['abi']
bytecode = contract_interface['bin']

# Deploy contract to WorldLand
price_in_wlc = Web3.toWei(0.01, 'ether')  # 0.01 WLC = 0.01 * 10^18 wei
ContentBilling = w3.eth.contract(abi=abi, bytecode=bytecode)
deploy_txn = ContentBilling.constructor(price_in_wlc).build_transaction({
    'from': deployer_address,
    'nonce': w3.eth.get_transaction_count(deployer_address),
    'chainId': chain_id,
    'gas': 500000,  # estimate of gas needed for deployment
    'gasPrice': w3.toWei(1, 'gwei')  # gas price in WLC (1 Gwei as example):contentReference[oaicite:11]{index=11}
})

# Sign and send the deployment transaction
signed_txn = deployer_account.sign_transaction(deploy_txn)
tx_hash = w3.eth.send_raw_transaction(signed_txn.rawTransaction)
print(f"Deploying contract... TX hash: {tx_hash.hex()}")
receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
contract_address = receipt.contractAddress
print(f"âœ” Contract deployed at address: {contract_address}")


class BillingAgent:
    """Agent that deploys a smart contract to bill users for content generated by ResearchAgent"""
    def __init__(self, contract_address=None):
        self._contract_address = contract_address
        self._owner_address = w3.eth.accounts[0]  # The owner address (deployment account)
        self._price_per_content = Web3.toWei(0.01, 'ether')  # Example: 0.01 ETH per content
        self._contract = None
        if self._contract_address:
            self._contract = w3.eth.contract(address=self._contract_address, abi=contract_abi)
        self._user_id = 'remote_agent'
        self._runner = Runner(
            app_name="research_agent",
            agent=LlmAgent(model="gemini-2.5-flash-preview-05-20"),
            artifact_service=InMemoryArtifactService(),
            session_service=InMemorySessionService(),
            memory_service=InMemoryMemoryService(),
        )

    def deploy_contract(self):
        # Deploy the contract
        contract = w3.eth.contract(abi=contract_abi, bytecode=contract_bytecode)
        tx = contract.constructor(self._price_per_content).buildTransaction({
            'from': self._owner_address,
            'gas': 2000000,
            'gasPrice': w3.toWei('20', 'gwei'),
            'nonce': w3.eth.getTransactionCount(self._owner_address),
        })
        signed_tx = w3.eth.account.signTransaction(tx, private_key='YOUR_PRIVATE_KEY')
        tx_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)
        tx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)
        print(f"Contract deployed at address: {tx_receipt.contractAddress}")
        self._contract_address = tx_receipt.contractAddress
        self._contract = w3.eth.contract(address=self._contract_address, abi=contract_abi)

    def get_content_and_bill(self, query, session_id):
        # Step 1: Use the ResearchAgent to generate content
        content_response = self._runner.run(query=query, session_id=session_id)

        if content_response.get('is_task_complete', False):
            # Get the content generated by ResearchAgent
            content = content_response.get('content', "")

            # Step 2: Interact with the deployed smart contract to process payment
            return self.bill_user_for_content(content)
        else:
            return {"error": "Failed to generate content"}

    def bill_user_for_content(self, content):
        # Bill the user via the smart contract
        user_address = 'USER_ETH_ADDRESS'  # The address that will pay for the content
        tx = self._contract.functions.purchaseContent().buildTransaction({
            'from': user_address,
            'value': self._price_per_content,
            'gas': 200000,
            'gasPrice': w3.toWei('20', 'gwei'),
            'nonce': w3.eth.getTransactionCount(user_address),
        })
        signed_tx = w3.eth.account.signTransaction(tx, private_key='USER_PRIVATE_KEY')
        tx_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)
        tx_receipt = w3.eth.waitForTransactionReceipt(tx_hash)

        print(f"Payment successful! Transaction hash: {tx_receipt.transactionHash.hex()}")

        # Step 3: Return the content after successful payment
        return {"content": content, "transaction_hash": tx_receipt.transactionHash.hex()}


class RearchAgentExecutor(AgentExecutor):
    """Agent Executor for Billing Agent"""

    def __init__(self):
        self.agent = BillingAgent()
    
    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        task = context.current_task

        # This agent always produces Task objects. If this request does
        # not have current task, create a new one and use it.
        if not task:
            task = new_task(context.message)
            event_queue.enqueue_event(task)
        updater = TaskUpdater(event_queue, task.id, task.contextId)

        # invoke the underlying agent, using streaming results. The streams
        # now are update events.
        async for item in self.agent.stream(task.contextId):
            is_task_complete = item['is_task_complete']
            artifacts = None
            if not is_task_complete:
                updater.update_status(
                    TaskState.working,
                    new_agent_text_message(
                        item['updates'], task.contextId, task.id
                    ),
                )
                continue

            # If the response is a dictionary, assume its a form
            if isinstance(item['content'], dict):
                # Verify it is a valid form
                if (
                    'response' in item['content']
                    and 'result' in item['content']['response']
                ):
                    data = json.loads(item['content']['response']['result'])
                    updater.update_status(
                        TaskState.input_required,
                        new_agent_parts_message(
                            [Part(root=DataPart(data=data))],
                            task.contextId,
                            task.id,
                        ),
                        final=True,
                    )
                    continue
                else:
                    updater.update_status(
                        TaskState.failed,
                        new_agent_text_message(
                            'Reaching an unexpected state',
                            task.contextId,
                            task.id,
                        ),
                        final=True,
                    )
                    break
            else:
                # Emit the appropriate events
                updater.add_artifact(
                    [Part(root=TextPart(text=item['content']))], name='form'
                )
                updater.complete()
                break
    
    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        raise Exception('cancel not supported')


# TODO: interact with smart contract
# TODO: separate agent from executor (maybe?)